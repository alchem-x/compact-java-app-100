import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.event.KeyEvent;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

// ÊñáÊú¨ÁÆ°ÁêÜÈùôÊÄÅÂÜÖÈÉ®Á±ª
static class Texts {
    // Á™óÂè£Ê†áÈ¢ò
    static final String WINDOW_TITLE = "üî¢ 2048 Ê∏∏Êàè";

    // ÁïåÈù¢Ê†áÁ≠æ
    static final String GAME_TITLE = "2048";
    static final String SCORE_TITLE = "ÂàÜÊï∞";
    static final String BEST_SCORE_TITLE = "ÊúÄÈ´òÂàÜ";
    static final String INSTRUCTION_TEXT = "üéÆ ‰ΩøÁî®ÊñπÂêëÈîÆÁßªÂä®ÊñπÂùóÔºåÂêàÂπ∂Áõ∏ÂêåÊï∞Â≠óÔºåËææÂà∞2048ÔºÅ";
    static final String START_GAME_STATUS = "ÂºÄÂßãÊ∏∏ÊàèÔºÅ";
    static final String WIN_MESSAGE = "ÊÅ≠ÂñúÔºÅ‰Ω†Ëµ¢‰∫ÜÔºÅÁªßÁª≠Ê∏∏ÊàèÂèØ‰ª•ËææÂà∞Êõ¥È´òÂàÜÊï∞ÔºÅ";
    static final String WIN_DIALOG_TITLE = "ËÉúÂà©ÔºÅ";
    static final String WIN_DIALOG_MESSAGE = "ÊÅ≠ÂñúÔºÅ‰Ω†ÊàêÂäüÂêàÊàê2048ÔºÅ";
    static final String GAME_OVER_STATUS = "Ê∏∏ÊàèÁªìÊùüÔºÅ";
    static final String GAME_OVER_DIALOG_TITLE = "Ê∏∏ÊàèÁªìÊùü";
    static final String GAME_OVER_DIALOG_MESSAGE = "Ê∏∏ÊàèÁªìÊùüÔºÅÊúÄÁªàÂæóÂàÜÔºö";
    static final String UNDO_SUCCESS_STATUS = "Êí§ÈîÄÊàêÂäüÔºÅ";
    static final String UNDO_FAILED_STATUS = "Êó†Ê≥ïÊí§ÈîÄÔºÅ";

    // ÊåâÈíÆÊñáÊú¨
    static final String NEW_GAME_BUTTON = "üîÑ Êñ∞Ê∏∏Êàè";
    static final String UNDO_BUTTON = "‚Ü∂ Êí§ÈîÄ";

    // Â∏ÆÂä©‰ø°ÊÅØ
    static final String HELP_MESSAGE = """
        2048Ê∏∏Êàè‰ΩøÁî®ËØ¥ÊòéÔºö

        ‚Ä¢ Ê∏∏ÊàèÁõÆÊ†áÔºöÈÄöËøáÁßªÂä®ÊñπÂùóÔºåÂêàÂπ∂Áõ∏ÂêåÊï∞Â≠óÔºåÊúÄÁªàÂêàÊàê2048
        ‚Ä¢ Ê∏∏ÊàèËßÑÂàôÔºöÊØèÊ¨°ÁßªÂä®Âêé‰ºöÂú®Á©∫‰ΩçÈöèÊú∫ÁîüÊàê2Êàñ4ÔºåÂΩìÊó†Ê≥ïÁßªÂä®Êó∂Ê∏∏ÊàèÁªìÊùü
        ‚Ä¢ ËÆ°ÂàÜËßÑÂàôÔºöÊØèÊ¨°ÂêàÂπ∂Êï∞Â≠ó‰ºöËé∑ÂæóÁõ∏Â∫îÂàÜÊï∞ÔºåÁõÆÊ†áÊòØËé∑ÂæóÊúÄÈ´òÂàÜÊï∞

        Êìç‰ΩúËØ¥ÊòéÔºö
        ‚Ä¢ ‚Üë Êàñ WÔºöÂêë‰∏äÁßªÂä®
        ‚Ä¢ ‚Üì Êàñ SÔºöÂêë‰∏ãÁßªÂä®
        ‚Ä¢ ‚Üê Êàñ AÔºöÂêëÂ∑¶ÁßªÂä®
        ‚Ä¢ ‚Üí Êàñ DÔºöÂêëÂè≥ÁßªÂä®

        Ê∏∏ÊàèÊäÄÂ∑ßÔºö
        ‚Ä¢ Â∞ΩÈáèÂ∞ÜÂ§ßÊï∞Â≠óÁßªÂêë‰∏Ä‰∏™ÊñπÂêë
        ‚Ä¢ ‰øùÊåÅÊ∏∏ÊàèÊùøÊï¥Ê¥ÅÔºåÈÅøÂÖçÊï∞Â≠óÂàÜÊï£
        ‚Ä¢ ‰ºòÂÖàÂêàÂπ∂ËæÉÂ∞èÁöÑÊï∞Â≠ó
        ‚Ä¢ È¢ÑÁïôÁ©∫Èó¥ÁªôÊñ∞ÁöÑÊï∞Â≠ó
        ‚Ä¢ ÂêàÁêÜ‰ΩøÁî®Êí§ÈîÄÂäüËÉΩ

        ÁâπÊÆäÂäüËÉΩÔºö
        ‚Ä¢ Êñ∞Ê∏∏ÊàèÔºöÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
        ‚Ä¢ Êí§ÈîÄÔºöÊí§ÈîÄ‰∏ä‰∏ÄÊ≠•Êìç‰ΩúÔºàÈôê‰∏ÄÊ¨°Ôºâ

        Âø´Êç∑ÈîÆÔºö
        ÊñπÂêëÈîÆ/WASD - ÁßªÂä®ÊéßÂà∂
        Ctrl+Z - Êí§ÈîÄÊìç‰Ωú
        Ctrl+N - Êñ∞Ê∏∏Êàè
        Ctrl+H - ÊòæÁ§∫Â∏ÆÂä©
        F1 - ÊòæÁ§∫Â∏ÆÂä©
        """;
}

void main(String[] args) {
    SwingUtilities.invokeLater(() -> {
        new Game2048().setVisible(true);
    });
}

static class Game2048 extends JFrame {
    private static final int GRID_SIZE = 4;
    private static final int CELL_SIZE = 100;
    private static final int CELL_PADDING = 10;
    private static final int BOARD_SIZE = GRID_SIZE * CELL_SIZE + (GRID_SIZE + 1) * CELL_PADDING;

    private int[][] board;
    private int score;
    private int bestScore;
    private boolean gameWon;
    private boolean gameOver;
    private Random random = new Random();

    private JLabel scoreLabel;
    private JLabel bestScoreLabel;
    private JLabel statusLabel;
    private GameBoard gameBoard;
    private JButton newGameButton;
    private JButton undoButton;
    private Stack<GameState> undoStack;

    // È¢úËâ≤ÈÖçÁΩÆ
    private static final Color[] CELL_COLORS = {
        new Color(0xCDC1B4), // 0
        new Color(0xEEE4DA), // 2
        new Color(0xEDE0C8), // 4
        new Color(0xF2B179), // 8
        new Color(0xF59563), // 16
        new Color(0xF67C5F), // 32
        new Color(0xF65E3B), // 64
        new Color(0xEDCF72), // 128
        new Color(0xEDCC61), // 256
        new Color(0xEDC850), // 512
        new Color(0xEDC53F), // 1024
        new Color(0xEDC22E)  // 2048
    };

    private static final Color TEXT_DARK = new Color(0x776E65);
    private static final Color TEXT_LIGHT = new Color(0xF9F6F2);

    public Game2048() {
        board = new int[GRID_SIZE][GRID_SIZE];
        score = 0;
        bestScore = loadBestScore();
        gameWon = false;
        gameOver = false;
        undoStack = new Stack<>();

        initializeGUI();
        startNewGame();
        setupKeyboardShortcuts();
    }

    private void initializeGUI() {
        setTitle(Texts.WINDOW_TITLE);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        // È°∂ÈÉ®Èù¢Êùø
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        topPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));
        topPanel.setBackground(new Color(0xFAF8EF));

        // Ê†áÈ¢òÂíåÂàÜÊï∞Èù¢Êùø
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(new Color(0xFAF8EF));

        // Ê†áÈ¢ò
        JLabel titleLabel = new JLabel(Texts.GAME_TITLE);
        titleLabel.setFont(new Font("SF Pro Display", Font.BOLD, 64));
        titleLabel.setForeground(new Color(0x776E65));
        headerPanel.add(titleLabel, BorderLayout.WEST);

        // ÂàÜÊï∞Èù¢Êùø
        JPanel scorePanel = new JPanel(new GridLayout(2, 1, 10, 10));
        scorePanel.setBackground(new Color(0xFAF8EF));

        // ÂΩìÂâçÂàÜÊï∞
        JPanel currentScorePanel = new JPanel();
        currentScorePanel.setLayout(new BoxLayout(currentScorePanel, BoxLayout.Y_AXIS));
        currentScorePanel.setBackground(new Color(0xBBADA0));
        currentScorePanel.setBorder(BorderFactory.createEmptyBorder(5, 15, 5, 15));
        currentScorePanel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createEmptyBorder(5, 15, 5, 15),
            BorderFactory.createLineBorder(new Color(0xBBADA0), 8, true)
        ));

        JLabel scoreTitle = new JLabel(Texts.SCORE_TITLE);
        scoreTitle.setFont(new Font("Microsoft YaHei", Font.BOLD, 14));
        scoreTitle.setForeground(TEXT_LIGHT);
        scoreTitle.setAlignmentX(Component.CENTER_ALIGNMENT);

        scoreLabel = new JLabel(String.valueOf(score));
        scoreLabel.setFont(new Font("Microsoft YaHei", Font.BOLD, 20));
        scoreLabel.setForeground(TEXT_LIGHT);
        scoreLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        currentScorePanel.add(scoreTitle);
        currentScorePanel.add(scoreLabel);

        // ÊúÄÈ´òÂàÜÊï∞
        JPanel bestScorePanel = new JPanel();
        bestScorePanel.setLayout(new BoxLayout(bestScorePanel, BoxLayout.Y_AXIS));
        bestScorePanel.setBackground(new Color(0xBBADA0));
        bestScorePanel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createEmptyBorder(5, 15, 5, 15),
            BorderFactory.createLineBorder(new Color(0xBBADA0), 8, true)
        ));

        JLabel bestScoreTitle = new JLabel(Texts.BEST_SCORE_TITLE);
        bestScoreTitle.setFont(new Font("Microsoft YaHei", Font.BOLD, 14));
        bestScoreTitle.setForeground(TEXT_LIGHT);
        bestScoreTitle.setAlignmentX(Component.CENTER_ALIGNMENT);

        bestScoreLabel = new JLabel(String.valueOf(bestScore));
        bestScoreLabel.setFont(new Font("Microsoft YaHei", Font.BOLD, 20));
        bestScoreLabel.setForeground(TEXT_LIGHT);
        bestScoreLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        bestScorePanel.add(bestScoreTitle);
        bestScorePanel.add(bestScoreLabel);

        JPanel scoresContainer = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0));
        scoresContainer.setBackground(new Color(0xFAF8EF));
        scoresContainer.add(currentScorePanel);
        scoresContainer.add(bestScorePanel);

        headerPanel.add(scoresContainer, BorderLayout.EAST);

        topPanel.add(headerPanel);

        // ËØ¥ÊòéÊñáÂ≠ó
        JLabel instructionLabel = new JLabel(Texts.INSTRUCTION_TEXT);
        instructionLabel.setFont(new Font("Microsoft YaHei", Font.PLAIN, 14));
        instructionLabel.setForeground(TEXT_DARK);
        instructionLabel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
        topPanel.add(instructionLabel);

        // ÊåâÈíÆÈù¢Êùø
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        buttonPanel.setBackground(new Color(0xFAF8EF));

        newGameButton = new JButton(Texts.NEW_GAME_BUTTON);
        newGameButton.setFont(new Font("Microsoft YaHei", Font.BOLD, 14));
        newGameButton.setBackground(new Color(0x8F7A66));
        newGameButton.setForeground(TEXT_LIGHT);
        newGameButton.setFocusPainted(false);
        newGameButton.addActionListener(e -> startNewGame());

        undoButton = new JButton(Texts.UNDO_BUTTON);
        undoButton.setFont(new Font("Microsoft YaHei", Font.BOLD, 14));
        undoButton.setBackground(new Color(0x9E948A));
        undoButton.setForeground(TEXT_LIGHT);
        undoButton.setFocusPainted(false);
        undoButton.addActionListener(e -> undo());

        buttonPanel.add(newGameButton);
        buttonPanel.add(undoButton);

        topPanel.add(buttonPanel);

        // Áä∂ÊÄÅÊ†áÁ≠æ
        statusLabel = new JLabel(Texts.START_GAME_STATUS);
        statusLabel.setFont(new Font("Microsoft YaHei", Font.BOLD, 16));
        statusLabel.setForeground(TEXT_DARK);
        statusLabel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
        topPanel.add(statusLabel);

        add(topPanel, BorderLayout.NORTH);

        // Ê∏∏ÊàèÈù¢Êùø
        gameBoard = new GameBoard();
        add(gameBoard, BorderLayout.CENTER);

        // ËÆæÁΩÆÈîÆÁõòÁõëÂê¨Âô®
        addKeyListener(new GameKeyListener());
        setFocusable(true);

        // ËÆæÁΩÆÁ™óÂè£
        setSize(600, 700);
        setLocationRelativeTo(null);
        setResizable(false);
    }

    private void startNewGame() {
        board = new int[GRID_SIZE][GRID_SIZE];
        score = 0;
        gameWon = false;
        gameOver = false;
        undoStack.clear();

        updateScore();
        statusLabel.setText(Texts.START_GAME_STATUS);

        // Ê∑ªÂä†‰∏§‰∏™ÂàùÂßãÊñπÂùó
        addNewTile();
        addNewTile();

        gameBoard.repaint();
    }

    private void addNewTile() {
        List<Point> emptyCells = new ArrayList<>();

        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                if (board[i][j] == 0) {
                    emptyCells.add(new Point(i, j));
                }
            }
        }

        if (!emptyCells.isEmpty()) {
            Point cell = emptyCells.get(random.nextInt(emptyCells.size()));
            // 90%Ê¶ÇÁéáÁîüÊàê2Ôºå10%Ê¶ÇÁéáÁîüÊàê4
            board[cell.x][cell.y] = random.nextDouble() < 0.9 ? 2 : 4;
        }
    }

    private void saveGameState() {
        int[][] boardCopy = new int[GRID_SIZE][GRID_SIZE];
        for (int i = 0; i < GRID_SIZE; i++) {
            System.arraycopy(board[i], 0, boardCopy[i], 0, GRID_SIZE);
        }
        undoStack.push(new GameState(boardCopy, score));
    }

    private void undo() {
        if (!undoStack.isEmpty()) {
            GameState previousState = undoStack.pop();
            board = previousState.getBoard();
            score = previousState.getScore();
            updateScore();
            gameBoard.repaint();
            statusLabel.setText(Texts.UNDO_SUCCESS_STATUS);
        } else {
            statusLabel.setText(Texts.UNDO_FAILED_STATUS);
        }
    }

    private boolean move(int direction) {
        boolean moved = false;
        int[][] newBoard = new int[GRID_SIZE][GRID_SIZE];

        // Â§çÂà∂ÂΩìÂâçÁä∂ÊÄÅ
        for (int i = 0; i < GRID_SIZE; i++) {
            System.arraycopy(board[i], 0, newBoard[i], 0, GRID_SIZE);
        }

        switch (direction) {
            case KeyEvent.VK_UP:
                moved = moveUp();
                break;
            case KeyEvent.VK_DOWN:
                moved = moveDown();
                break;
            case KeyEvent.VK_LEFT:
                moved = moveLeft();
                break;
            case KeyEvent.VK_RIGHT:
                moved = moveRight();
                break;
        }

        if (moved) {
            saveGameState();
            addNewTile();
            updateScore();
            gameBoard.repaint();

            if (!gameWon && hasWon()) {
                gameWon = true;
                statusLabel.setText(Texts.WIN_MESSAGE);
                JOptionPane.showMessageDialog(this, Texts.WIN_DIALOG_MESSAGE, Texts.WIN_DIALOG_TITLE,
                    JOptionPane.INFORMATION_MESSAGE);
            } else if (isGameOver()) {
                gameOver = true;
                statusLabel.setText(Texts.GAME_OVER_STATUS);
                JOptionPane.showMessageDialog(this, Texts.GAME_OVER_DIALOG_MESSAGE + score, Texts.GAME_OVER_DIALOG_TITLE,
                    JOptionPane.INFORMATION_MESSAGE);
            }
        }

        return moved;
    }

    private boolean moveLeft() {
        boolean moved = false;

        for (int i = 0; i < GRID_SIZE; i++) {
            int[] row = new int[GRID_SIZE];
            for (int j = 0; j < GRID_SIZE; j++) {
                row[j] = board[i][j];
            }

            int[] newRow = mergeRow(row);
            for (int j = 0; j < GRID_SIZE; j++) {
                if (board[i][j] != newRow[j]) {
                    moved = true;
                }
                board[i][j] = newRow[j];
            }
        }

        return moved;
    }

    private boolean moveRight() {
        boolean moved = false;

        for (int i = 0; i < GRID_SIZE; i++) {
            int[] row = new int[GRID_SIZE];
            for (int j = 0; j < GRID_SIZE; j++) {
                row[j] = board[i][GRID_SIZE - 1 - j];
            }

            int[] newRow = mergeRow(row);
            for (int j = 0; j < GRID_SIZE; j++) {
                if (board[i][GRID_SIZE - 1 - j] != newRow[j]) {
                    moved = true;
                }
                board[i][GRID_SIZE - 1 - j] = newRow[j];
            }
        }

        return moved;
    }

    private boolean moveUp() {
        boolean moved = false;

        for (int j = 0; j < GRID_SIZE; j++) {
            int[] column = new int[GRID_SIZE];
            for (int i = 0; i < GRID_SIZE; i++) {
                column[i] = board[i][j];
            }

            int[] newColumn = mergeRow(column);
            for (int i = 0; i < GRID_SIZE; i++) {
                if (board[i][j] != newColumn[i]) {
                    moved = true;
                }
                board[i][j] = newColumn[i];
            }
        }

        return moved;
    }

    private boolean moveDown() {
        boolean moved = false;

        for (int j = 0; j < GRID_SIZE; j++) {
            int[] column = new int[GRID_SIZE];
            for (int i = 0; i < GRID_SIZE; i++) {
                column[i] = board[GRID_SIZE - 1 - i][j];
            }

            int[] newColumn = mergeRow(column);
            for (int i = 0; i < GRID_SIZE; i++) {
                if (board[GRID_SIZE - 1 - i][j] != newColumn[i]) {
                    moved = true;
                }
                board[GRID_SIZE - 1 - i][j] = newColumn[i];
            }
        }

        return moved;
    }

    private int[] mergeRow(int[] row) {
        int[] merged = new int[GRID_SIZE];
        int index = 0;
        boolean[] mergedFlags = new boolean[GRID_SIZE];

        // ÁßªÈô§Èõ∂
        for (int value : row) {
            if (value != 0) {
                if (index > 0 && merged[index - 1] == value && !mergedFlags[index - 1]) {
                    merged[index - 1] = value * 2;
                    score += value * 2;
                    mergedFlags[index - 1] = true;
                } else {
                    merged[index++] = value;
                }
            }
        }

        return merged;
    }

    private boolean hasWon() {
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                if (board[i][j] == 2048) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isGameOver() {
        // Ê£ÄÊü•ÊòØÂê¶ÊúâÁ©∫‰Ωç
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                if (board[i][j] == 0) {
                    return false;
                }
            }
        }

        // Ê£ÄÊü•ÊòØÂê¶ËøòËÉΩÂêàÂπ∂
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                int current = board[i][j];
                // Ê£ÄÊü•Âè≥Ëæπ
                if (j < GRID_SIZE - 1 && board[i][j + 1] == current) {
                    return false;
                }
                // Ê£ÄÊü•‰∏ãËæπ
                if (i < GRID_SIZE - 1 && board[i + 1][j] == current) {
                    return false;
                }
            }
        }

        return true;
    }

    private void updateScore() {
        scoreLabel.setText(String.valueOf(score));
        if (score > bestScore) {
            bestScore = score;
            bestScoreLabel.setText(String.valueOf(bestScore));
            saveBestScore();
        }
    }

    private void saveBestScore() {
        try {
            java.util.prefs.Preferences prefs = java.util.prefs.Preferences.userNodeForPackage(Game2048.class);
            prefs.putInt("bestScore", bestScore);
        } catch (Exception e) {
            // ÂøΩÁï•‰øùÂ≠òÈîôËØØ
        }
    }

    private int loadBestScore() {
        try {
            java.util.prefs.Preferences prefs = java.util.prefs.Preferences.userNodeForPackage(Game2048.class);
            return prefs.getInt("bestScore", 0);
        } catch (Exception e) {
            return 0;
        }
    }

    // Ê∏∏ÊàèÈù¢Êùø
    class GameBoard extends JPanel {
        public GameBoard() {
            setPreferredSize(new Dimension(BOARD_SIZE, BOARD_SIZE));
            setBackground(new Color(0xBBADA0));
            setFocusable(true);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            drawBoard(g);
        }

        private void drawBoard(Graphics g) {
            Graphics2D g2d = (Graphics2D) g;
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            // ÁªòÂà∂ËÉåÊôØÁΩëÊ†º
            for (int i = 0; i < GRID_SIZE; i++) {
                for (int j = 0; j < GRID_SIZE; j++) {
                    int x = j * CELL_SIZE + (j + 1) * CELL_PADDING;
                    int y = i * CELL_SIZE + (i + 1) * CELL_PADDING;

                    // ÁªòÂà∂ÂçïÂÖÉÊ†ºËÉåÊôØ
                    g2d.setColor(CELL_COLORS[0]);
                    g2d.fillRoundRect(x, y, CELL_SIZE, CELL_SIZE, 10, 10);

                    // ÁªòÂà∂Êï∞Â≠ó
                    int value = board[i][j];
                    if (value != 0) {
                        drawTile(g2d, value, x, y);
                    }
                }
            }
        }

        private void drawTile(Graphics2D g2d, int value, int x, int y) {
            // Ëé∑ÂèñÈ¢úËâ≤Á¥¢Âºï
            int colorIndex = (int) (Math.log(value) / Math.log(2));
            if (colorIndex >= CELL_COLORS.length) {
                colorIndex = CELL_COLORS.length - 1;
            }

            // ÁªòÂà∂ÂçïÂÖÉÊ†º
            g2d.setColor(CELL_COLORS[colorIndex]);
            g2d.fillRoundRect(x, y, CELL_SIZE, CELL_SIZE, 10, 10);

            // ÁªòÂà∂Êï∞Â≠ó
            g2d.setColor(value > 4 ? TEXT_LIGHT : TEXT_DARK);

            // Ê†πÊçÆÊï∞Â≠óÂ§ßÂ∞èË∞ÉÊï¥Â≠ó‰Ωì
            int fontSize;
            if (value < 100) {
                fontSize = 36;
            } else if (value < 1000) {
                fontSize = 32;
            } else if (value < 10000) {
                fontSize = 28;
            } else {
                fontSize = 24;
            }

            g2d.setFont(new Font("Microsoft YaHei", Font.BOLD, fontSize));

            String text = String.valueOf(value);
            FontMetrics fm = g2d.getFontMetrics();
            int textWidth = fm.stringWidth(text);
            int textHeight = fm.getAscent();

            int textX = x + (CELL_SIZE - textWidth) / 2;
            int textY = y + (CELL_SIZE + textHeight) / 2 - 5;

            g2d.drawString(text, textX, textY);
        }
    }

    // ÈîÆÁõòÁõëÂê¨Âô®
    class GameKeyListener extends KeyAdapter {
        @Override
        public void keyPressed(KeyEvent e) {
            if (gameOver) {
                return;
            }

            boolean moved = false;
            switch (e.getKeyCode()) {
                case KeyEvent.VK_UP:
                case KeyEvent.VK_W:
                    moved = move(KeyEvent.VK_UP);
                    break;
                case KeyEvent.VK_DOWN:
                case KeyEvent.VK_S:
                    moved = move(KeyEvent.VK_DOWN);
                    break;
                case KeyEvent.VK_LEFT:
                case KeyEvent.VK_A:
                    moved = move(KeyEvent.VK_LEFT);
                    break;
                case KeyEvent.VK_RIGHT:
                case KeyEvent.VK_D:
                    moved = move(KeyEvent.VK_RIGHT);
                    break;
                case KeyEvent.VK_Z:
                    // Ctrl+Z Êí§ÈîÄ
                    if (e.isControlDown()) {
                        undo();
                    }
                    break;
                case KeyEvent.VK_N:
                    // Ctrl+N Êñ∞Ê∏∏Êàè
                    if (e.isControlDown()) {
                        startNewGame();
                    }
                    break;
                case KeyEvent.VK_H:
                    // Ctrl+H ÊòæÁ§∫Â∏ÆÂä©
                    if (e.isControlDown()) {
                        showHelp();
                    }
                    break;
                case KeyEvent.VK_F1:
                    // F1ÈîÆÊòæÁ§∫Â∏ÆÂä©
                    showHelp();
                    break;
            }
        }
    }

    private void setupKeyboardShortcuts() {
        // Ê∑ªÂä†È¢ùÂ§ñÁöÑÈîÆÁõòÂø´Êç∑ÈîÆÊîØÊåÅ
        this.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent ev) {
                int keyCode = ev.getKeyCode();

                switch (keyCode) {
                    case KeyEvent.VK_H:
                        // HÈîÆÊòæÁ§∫Â∏ÆÂä©
                        if (ev.isControlDown()) {
                            showHelp();
                        }
                        break;
                    case KeyEvent.VK_F1:
                        // F1ÈîÆÊòæÁ§∫Â∏ÆÂä©
                        showHelp();
                        break;
                    default:
                        return;
                }
            }
        });

        // Á°Æ‰øùÁ™óÂè£ÂèØ‰ª•Ëé∑ÂæóÁÑ¶ÁÇπ
        this.setFocusable(true);
        this.requestFocusInWindow();
    }

    private void showHelp() {
        JOptionPane.showMessageDialog(this, Texts.HELP_MESSAGE, "Â∏ÆÂä©", JOptionPane.INFORMATION_MESSAGE);
    }

    // Ê∏∏ÊàèÁä∂ÊÄÅÁ±ª
    static class GameState {
        private int[][] board;
        private int score;

        public GameState(int[][] board, int score) {
            this.board = new int[GRID_SIZE][GRID_SIZE];
            for (int i = 0; i < GRID_SIZE; i++) {
                System.arraycopy(board[i], 0, this.board[i], 0, GRID_SIZE);
            }
            this.score = score;
        }

        public int[][] getBoard() {
            return board;
        }

        public int getScore() {
            return score;
        }
    }
}